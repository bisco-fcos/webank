# Can You Feel Me 制作第一周-开发记录

## 周一
### Description：Demo第一关-游乐场的设计想法与实现情况

### 1. 关卡功能-风力
思路简述：场景中有某一个物体（如风扇）能够制造风场，而玩家的心跳频率会影响风力大小。玩家需要控制风力的大小以将可吹动的物体（如气球之类的东西）移动到某个特定的位置来触发机关<br/>机关1：场景中有一个不停循环上升的气球（达到一定高度后自动销毁并重新出现），玩家需要通过风力控制其x、z轴以使其上升到指定位置并触发机关

### 2. 关卡功能-引力
 思路简述：场景中有某一个物体（如黑洞），该物体会不断牵引物体到其中心，暂定为一种阻挠、影响玩家行进路线的物体<br/>机关1.可以将惯性+引力的双重作用设计为玩家过关时所必须的元素<br/> 2.黑洞的可以将物体操控到黑洞附近并且将其销毁（待定）。

## 周二
### Description：Demo第一关-关卡视角讨论与设定
视角描述：第三人称视角 相机会跟随人物进行移动 按下鼠标右键：以人物为中心上下左右旋转，有最大视角限制 鼠标滚轮：进行缩放，有最大、最小缩放限制 

人物移动情况描述：Forward方向为Camera的朝向，WASD会一直保持前后左右的移动方向 
```csharp
    private Vector3 angle;
    public Transform centerPoint;
    private float rotateSpeed=2;
    private GameObject _mainCamera;
    private float maxRotAngle=70, minRotAngle=10;
    public float scrollSpeed;

    Vector3 original_offset;

    void Start()
    {
        _mainCamera = Camera.main.gameObject;
        //向量初始化
        original_offset = _mainCamera.transform.position - centerPoint.position;
    }

  
    void Update()
    {
        
        this.transform.LookAt(centerPoint.position);
        //Update中通过上一帧的矢量信息和新的人物位置对相机位置进行更新
        _mainCamera.transform.position = original_offset + centerPoint.position;
    }

    public void CameraRotate(float _mouseX, float _mouseY)
    {       
        if (Input.GetMouseButton(1))
        {
            //控制相机绕中心点(centerPoint)水平旋转
            _mainCamera.transform.RotateAround(centerPoint.position, Vector3.up, _mouseX * rotateSpeed);
            angle = limitrotate(angle);
            if ((angle.x > maxRotAngle && _mouseY<0) || (angle.x < minRotAngle&&_mouseY > 0))
            {                
                return;
            }            
            _mainCamera.transform.RotateAround(centerPoint.position, _mainCamera.transform.right, _mouseY *-rotateSpeed);                          
        }
        
        //视角缩放
        if (Input.GetAxis("Mouse ScrollWheel") != 0)
        {
            this.gameObject.transform.Translate(new Vector3(0, 0, Input.GetAxis("Mouse ScrollWheel") * Time.deltaTime * scrollSpeed));
        }
        //相机旋转、缩放之后记录此时此刻人物与相机之间的矢量信息
        original_offset = _mainCamera.transform.position - centerPoint.position;
    }
   
    //在Update之后进行相机旋转的相关设定
    public void LateUpdate()
    {
        angle = transform.eulerAngles;
        float _mouseX = Input.GetAxis("Mouse X");
        float _mouseY = Input.GetAxis("Mouse Y");
        CameraRotate(_mouseX, _mouseY);

    }

    //视角限制
    private Vector3 limitrotate(Vector3 angle)
    {
        angle.x -= 180;
        if (angle.x > 0)
            angle.x -= 180;
        else
            angle.x += 180;
        angle.z = 0;
        return angle;
    }
```



