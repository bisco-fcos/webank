## 第一节课程   

介绍了Solidity的基本语法，从基本定义contract，函数的命名，返回值的定义，private和public的用法及区别。pure和view。以及事件的定义。   

## 第二节课程  
1.mapping用于映射，可用于查找address，或查找Id。   
2.require语句用于判断，当判断条件不符合时，函数被结束，条件符合时，函数继续执行。   
3.随后则是关于合约继承的public、private、external、internal之间的对比（internal为只有合约内部和子合约内部可调用的函数，external则是本合约内部无法访问，合约外部的任何函数都可以访问)。  
4.合约和接口的定义都采用了contract关键字，区别之处在于接口内的函数没有函数体（即没有{}），用于合约之间的交互。   
5.solidity语言的特性——多返回值。   

## 第三节课程   
1.在你把智能协议传上以太坊之后，它就变得不可更改, 这种永固性意味着你的代码永远不能被调整或更新。因此，我们可以通过添加外部依赖来实现对合约的修改。     
2.External使得外部的任何人都可以调用协议，有很大的不安全性。因此，我们引入Ownable合约，指定合约的所有权。使用modifier告诉编译器这个修饰符，而不是函数。函数修饰符也可以带有参数。修饰符最后一行用_;表示修饰符调用结束后返回，并执行调用函数余下的部分。   
3.在以太坊上使用资源要用到Gas，付费较大。省Gas的方法：结构封装。View(view 不花gas)   
4.时间单位：直接用now会返回一个秒数，从1970年1月1日计算的来的。默认32位存储，可根据需要修改。Solidity 还包含秒(seconds)，分钟(minutes)，小时(hours)，天(days)，周(weeks) 和 年(years) 等时间单位。   
5.Storage存储十分昂贵，故而更倾向于用memory和view。Memory数组必须使用长度参数。    
6.For循环，与C++类似。

## 第四节课程   
1.可支付payable修饰符，表明函数是付费使用的。         
2.随机数：keccak256 哈希函数。这种创建随机数的方法是不安全的，容易被攻击。     
3.重构通用逻辑：运用修饰符，修改原本使用require语句的位置。   
4.后续都是对僵尸添加一些新的功能，没有涉及新的语法对岸。添加了僵尸战斗功能，并为他们设定排行榜。     
## 第五节课程    
1.讲解了以太网的其他代币，并不是所有的代币都可以用小数表达，ERC721 代币是不能互换的，因为每个代币都被认为是唯一且不可分割的。 你只能以整个单位交易它们，并且每个单位都有唯一的 ID。 这些特性正好让我们的僵尸可以用来交易。    
2.BalanceOf和ownerOf：balanceOf以地址为参数返回该用户的拥有多少代币，ownerOf以id为参数，返回地址。     
3.ERC271有两种标准方法转移代币：第一种方法是代币的拥有者调用transfer 方法，传入他想转移到的 address 和他想转移的代币的 _tokenId。第二种方法是代币拥有者首先调用 approve，然后传入与以上相同的参数。接着，该合约会存储谁被允许提取代币，通常存储到一个 mapping (uint256 => address) 里。然后，当有人调用 takeOwnership 时，合约会检查 msg.sender 是否得到拥有者的批准来提取代币，如果是，则将代币转移给他。        
4.预防溢出：溢出和下溢。可使用SafeMath预防。塔为原始数据添加了一些方法。包括了加减乘除，不同的是，他添加了溢出的判断。      
5.代码注释和 natspec 标准。
